### 디피-헬먼
- 키 교환 알고리즘
	- 공유하는 대칭키를 전달하기 위해 사용
- 암호화나 서명을 위해 사용되지 않음
- DH 보안성은 이산로그 문제의 난이도에 기반
- p를 큰 값의 소수, g를 생성자라고 한다.
	-  x = g^n mod p를 만족하는 g와 n이 존재
	-  g는 p의 윈시근이라고 함
	-  g mod p, g^2 mod p, ...., g^p-1 mod p 가 모두 다르면 1 부터 p-1을 생성

- 키 교환 동작
	- g, p는 공개
	- 앨리스 동작
		- 비밀값 a ( < p) 를 랜덤으로 선정
		- g^a mod p를 밥에게 전송
	- 밥 동작
		- 비밀값 b ( < p) 를 랜덤으로 선정
		- g^b mod p를 밥에게 전송
	- 둘 모두 공유 비밀키 K = g^ab mod p를 계산
	- 공유 비밀키는 대칭 키로 사용

- 트루디는  g^a mod p 와  g^b mod p를 볼 수 있음
- 만약 트루디가 a 또는 b를 찾으면, 체계는 해독
- 만약 트루디가 이산로그 문제를 풀 수 있으면, a 또는 b를 찾을 수 있음

### 디피-헬먼의 약점
- 중간자 공격 (MIM)에 취약
- 중간자 공격 (MIM)를 방지하는 방법
	- 대칭키로 DH 교환 값을 암호화 (모순)
	- 공개키로 DH 교환 값을 암호화
	- DH 교환 값을 개인키로 서명

### 타원 곡선 암호 (ECC ) : 생략
- 새로운 공개키 암호체계는 아님, 암호체계가 요구하는 암호 연산만 대치 : 디피-핼먼의 타원곡선 버전
- 같은 수준의 보안성을 제공하기 위한 비트가 적게 사용되고, 비교적 빠른 연산이 가능 : 암호화폐 등에 활용
- 그렇지만 수학 연산은 복잡

### 공개키 표기법
- 암호화 : 앨리스의 공개키로 메시지 M 암호화
	- C = { M } 앨리스
- 복호화 : 앨리스의 개인키로 메시지 M 복호화
	- M = [ C ] 앨리스
- 서명 : 앨리스의 개인키로 메시지 M 서명
	- S = [ M ] 앨리스
- [ ] => 개인키 , { } => 공개키

### 공개키의 용도 (장점)
- 비밀성 보장 ( 암호화 / 복호화 연산이 느리지 만 대칭키의 기능을 모두 수행)
	- 데이터를 안전하지 않은 채널로 전송
	- 안전하지 않은 미디어에 안전하게 저장
- 개인키에 의한 전자 서명
	- 무결성과 부인봉쇄 (non-Repudiation)를 제공
	- 대칭키로 부인봉쇄는 불가
- 장점
	- 비밀성에서 공유키 교환(전달)이 필요 없음
	- 전자 서명에 의해 메시지 무결성과 부인봉쇄 가능

### 현실세계의 보안성
- 합성(Hybrid) 암호체계
	- 대칭키의 장점 ( 효율성 ) + 공유키 장점 (키 전달 문제 해결)
	- 공개키 암호는 대칭키를 설정하기 위해 사용
	- 대칭키는 데이터 암호화/복호화에 사용
- 밥은 자신의 대화 상대가 진짜 앨리스 인지 확인할 방법이 없다.
- 앨리스는 자신의 대화 상대가 진짜 밥 인지 확인할 수 있다. -> 복호화가 제대로 이루어 진다는 것은 밥이 본인의 개인키로 복호화를 했다는 소리다.	

### 부인봉쇄 필요성
- 앨리스는 밥으로 부터 100장의 주식을 주문
- 앨리스는 대칭키를 이용하여 MAC를 계산
- 주식값 폭락, 앨리스는 주문하지 않았다고 주장
- 밥이 앨리스의 주문을 증명할 수 있는가?
- 할 수 없다. 밥도 역시 대칭키를 알고 있기 때문에 메시지를 속일 수 있다.
- 문제 : 밥은 앨리스 주문을 한것을 알고 있지만 증명할 수가 없다.


### 비밀성과 부인봉쇄
- 공개키 암호로 비밀성과 부인봉쇄를 사용하는 경우
- 앨리스가 밥에게 메시지 전송
	- 선 서명 후, 밥의 공개키로 암호화 ; { [ M ] 앨리스 }밥
	- 밥의 공개키로 선 암호화 후, 서명 : [ { M } 밥 } 앨리스
-  순서가 의미가 있는것인가?

- 시나리오 1 : 선 서명 후, 암호화
	- M : "나는 당신을 죽도록 사랑합니다."
	- { [ M ] 앨리스 } 밥   =>  { [ M ] 앨리스 } 챨리 
	- 문제  : 챨리는 앨리스가 자신을 사랑한다는 착각
	- 챨리의 공개키는 항상 공개되어 있음을 명심해야 함

- 시나리오 2 : 선 암호화 후, 서명
	- M : "이성과 열정"
	- [ { M } 밥 ] 앨리스 => [ { M } 밥 ] 챨리
	- 찰리는 M을 복호화 할 수 없음
	- 문제 : 밥은 챨리가 이 메시지를 보냈다고 착각
	- 앨리스의 서명은 누구나 제거 가능함을 명심	

### 공개키 기반 구조 : 공개키 인증서
- PKI (Public Key Infrastructure)
	- 공개키 암호를 안전하게 사용하기 위해 필요한 총체 ( 기반 체계)
	- 공개키 기반체계는 공개키 암호를 안전하게 사용하는데 필요한 모든 요소들로 구성
		- 키 생산과 관리
		- 인증 기관
		- 인증 폐기 등
	- PKI 일반적인 표준은 없음
	- 몇 가지  "신뢰 모델들" 존재

	- 완전 독점 모델
		- 모든 분야의 신뢰 조직은 하나의 CA만을 사용
		- VeriSign을 가장 선호
		- 만약 CA가 공격받아 손상되면 큰 문제가 발생
		- 만약 CA를 신뢰하지 못하는 것 큰 문제
	- 소수 독점 모델
		- 다수의 신뢰받는 CA
		- 이 접근 방법이 현재 인터넷 브라우저에서 사용
		- 브라우저는 서명들을 확인하기 위해 80개 이상의 인증서를 보유
		- 사용자는 신뢰하는 CA를 결정할 수 있음
	- 완전 자유 모델
		- 모든 사람이 하나의 CA
		- 사용자가 어떤 CA를 신뢰할 것인지 결정
		- 이 접근 방법은 PGP (신뢰의 웹)에서 사용
		- 사용자에게 큰 부담을 지게 함

- 전자 인증서 (Digital Certificate) (공개키 인증서, 인증서)
	- 사용자의 공개키와 이름을 포함
	- 인증서의 인증 기관 (CA) 서명 (인증서 보증)
	- 추가 정보 ( 각종 일련번호, 알고리즘, 사용자 관련 정보 등)
	- 인증서의 일반 양식 표준은 X.509

- 인증서의 서명은 서명자 (CA)의 공개키로 확인 가능

- 인증 기관 : CA (Certificate Authority)
	- 인증서에 서명하고 그 인증서를 발행하는 제 3의 신뢰성 있는 기관
	- 인증서의 CA 서명은 사용자가 개인키를 가지고 있음을 보증
	- 인증서 보유자의 신원 보증은 아님 (인증서는 공개)
	- 인증서는 이 증서를 보증할 발행자가 서명

	- 만약 CA가 잘못하면 큰 문제가 발생